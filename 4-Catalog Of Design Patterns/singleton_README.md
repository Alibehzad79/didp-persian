## Singleton
الگوی **Singleton** 
یک الگوی  تولیدی یا به طور ساده تر خلاقانه است که به شما این امکان را می دهد اطمینان حاصل کنید که یک کلاس فقط یک نمونه یا همون آبجکت دارد ، و دسترسی همگانی به این آبجکت داده میشه

###  مشکل 😟 

الگوی سینگلتون دو مشکل اصلی را همزمان حل میکند اما با هزینه نقض اصل  
Single Responsibility Principle در اصول SOLID

اول از همه از هر کلاس یک موجودیت یا آبجکت را تولید میکند یعنی به ما این اطمینان را میدهد که از کلاس فقط و فقط یک آبجکت ساخته میشود چرا باید بخواهیم که روی تعداد آبجکت های یک کلاس کنترل داشته باشیم؟
رایج ترین دلیل این امر کنترل دسترسی به برخی از منابع مشترک است - به عنوان مثال، یک پایگاه داده یا یک فایل.

حال چه طور ممکن است بگذارید مسئله را بازش کنیم 
نحوه کار به این صورت است: تصور کنید که یک شی ایجاد کرده اید، اما پس از مدتی تصمیم به ایجاد یک شی جدید دارید. به جای دریافت یک شیء تازه، شیئی را که قبلا ایجاد کرده اید دریافت خواهید کرد.

توجه داشته باشید که اجرای این رفتار با یک سازنده غیرممکن است زیرا یک فراخوان سازنده همیشه باید یک شی جدید را با طراحی   برگرداند به وصرت تدریجی به این قسمت هم میرسیم
![مشتریان حتی ممکن است متوجه نشوند که همیشه با یک شی کار می کنند.](https://github.com/ftg-iran/didp-persian/raw/main/4-Catalog%20Of%20Design%20Patterns/images/content/singleton/singleton-comic-1-en.png)


این دیزاین پترن یک نقطه دسترسی گلوبال به آن ابجکت ارائه میدهد . متغیرهای گلوبال را که شما برای ذخیره برخی از آبجکت ضروری استفاده کردید، به خاطر دارید؟ اگرچه آنها بسیار مفید هستند، اما بسیار 
ناامن هستند زیرا هر کدی می تواند محتویات آن متغیرها را بازنویسی کند و برنامه را خراب کند.
به صورت کلی در برنامه هر کسی بهش دسترسی دارد. 

نتیجه کلی که میتوانیم بگیریم این است که 
**singleton** 
به ما کمک میکند و اجازه میدهد که از هر جای برنامه که یه شی هست از این دیزاین پترن استفاده کنیم از طرفی جلوی عوض شدن و تغییر داخل یک سری از آبجکت ها را میگیرد یعنی، آن آبجکت را از بازنویسی شدن توسط کدهای دیگر نیز محافظت می کند

###    راه حل 
  : تمام پیاده سازی های این الگو دو گام مشترک دارند 
   
   
اول از همه متود سازنده پیش فرض آبجکت را خصوصی (private) کنید تا دیگر اشیا از عملگر new همراه با کلاس Singleton
.استفاده نکنند

دوم یک  روش استتیک  ایجاد کنید که به عنوان سازنده عمل کند . تحت این شرایط ، این روش سازنده پرایوت را برای ایجاد یک شی فراخوانی می کند و آن را در یک فیلد ثابت ذخیره می کند. همه فراخوانی های بعدی به این متد، آبجکت ذخیره شده را برمی گرداند.

 ### در دنیای واقعی singleton  🚗  
 دولت نمونه ای عالی از الگوی سینگلتون است. یک کشور می تواند تنها یک دولت رسمی داشته باشه صرف نظر از هویت شخصی افراد تشکیل دهنده دولت،
 مثلا : 
 «دولت ایکس یک نقطه دسترسی گلوبال است که گروه افراد مسئول را مشخص می کند.
 **




 
کلاس سینگلتون با متود یا همان تابع داخلی خودش به نام 
getInstance  همان آبجکت قبلی را بر میگرداند یعنی اگر ازین کلاس شیءی ساخته نشده بود یک آبجکت ساخته و آن را بر میگرداند اگر از قبل ساخته شده بود دیگر آبجکت جدیدی نمیسازد و همان آبجکت قبلی را که داخل متغیری  به نام 
instance 
دخیره کرده بودیم بر میگرداند. 

### قطعه کد نمونه#️⃣  
در این مثال، کلاس اتصال پایگاه داده به عنوان
 Singleton
 عمل می کند. این کلاس سازنده عمومی ندارد، بنابراین تنها راه برای دریافت شیء آن فراخوانی متد getInstance است. این متد اولین آبجکت ایجاد شده را کش می کند و در تمام فراخوانی های بعدی آن را برمی گرداند.

``` c++
    // The Database class defines the `getInstance` method that lets
    // clients access the same instance of a database connection
    // throughout the program.
        class Database is
        // The field for storing the singleton instance should be
        // declared static.
        private static field instance: Database

    // The singleton's constructor should always be private to
    // prevent direct construction calls with the `new`
    // operator.
    private constructor Database() is
        // Some initialization code, such as the actual
        // connection to a database server.
        // ...
    // The static method that controls access to the singleton
    // instance.
    public static method getInstance() is
        if (Database.instance == null) then
            acquireThreadLock() and then
            // Ensure that the instance hasn't yet been
            // initialized by another thread while this one
            // has been waiting for the lock's release.
            if (Database.instance == null) then
                Database.instance = new Database()
        return Database.instance

    // Finally, any singleton should define some business logic
    // which can be executed on its instance.
    public method query(sql) is
        // For instance, all database queries of an app go
        // through this method. Therefore, you can place
        // throttling or caching logic here.
        // ...

    class Application is
    method main() is
        Database foo = Database.getInstance()
        foo.query("SELECT ...")
        // ...
        Database bar = Database.getInstance()
        bar.query("SELECT ...")
        // The variable `bar` will contain the same object as
        // the variable `foo
```

### 💡  قابلیت اجرا 
از الگوی
 Singleton
  زمانی استفاده کنید که یک کلاس در برنامه شما باید فقط یک آبجکت در دسترس همه کلاینت ها باشد. به عنوان مثال، یک شی پایگاه داده تک  که توسط بخش های مختلف برنامه به اشتراک گذاشته شده است.
  ✨ الگوی 
  Singleton 
  تمام روش های  دیگر برای ایجاد اشیاء یک کلاس را غیرفعال می کند، به جز روش ایجاد خاص. این متد یا یک شی جدید ایجاد می کند یا اگر قبلاً ایجاد شده باشد، یک آبجکت را برمی گرداند.
  ✨ برخلاف متغیرهای سراسری الگوی
  Singleton
   تضمین می‌کند که فقط یک نمونه از یک کلاس وجود دارد. هیچ چیز، به جز خود کلاس Singleton،
    نمی تواند جایگزین نمونه ذخیره شده شود.
    
 ### 📋  چگونه پیاده سازی کنیم؟
 
یک فیلد استاتیک خصوصی به کلاس برای ذخیره نمونه 
**singleton**
 اضافه کنید.

یک روش ایجاد استاتیک عمومی برای به دست آوردن نمونه سینگلتون مشخص کنید.

در متود استاتیک، "lazy initialization" را پیاده سازی کنید. باید در اولین فراخوانی خود یک شی جدید ایجاد کرده و آن را در فیلد استاتیک قرار دهد. متد همیشه باید آن نمونه را در تمام فراخوانی های بعدی برگرداند.




سازنده کلاس را خصوصی کنید. متد استاتیک کلاس همچنان قادر خواهد بود سازنده را فراخوانی کند، اما سایر اشیاء را نه.

روی کد کلاینت بروید و همه ارتباط های مستقیم سازنده singleton را با فراخوانی‌های روش  با  با ایجاد استاتیک آن جایگزین کنید.

### ⚖️    سود و ضررها ؟
✔️ می توانید مطمئن باشید که یک کلاس فقط یک نمونه دارد.
✔️ شما یک نقطه دسترسی گلوبال به آن نمونه بدست می آورید.

✔️ شی 
singleton
 فقط زمانی مقداردهی اولیه می شود که برای اولین بار درخواست شود.

✖️ اصل the Single Responsibility
 را نقض می کند. این الگو در آن زمان دو مشکل را حل می کند .

✖️ الگوی 
Singleton 
می تواند طراحی بد را پنهان کند، برای مثال، زمانی که اجزای برنامه اطلاعات زیادی درباره یکدیگر دارند.

✖️ این الگو نیاز به رفتار خاص در یک محیط چند رشته ای دارد به طوری که نخ های متعدد چندین بار یک شی تک را ایجاد نکنند.

✖️ ممکن است تست نویسی  واحد کد کلاینت 
Singleton
 دشوار باشد زیرا بسیاری از چارچوب‌های آزمایشی هنگام تولید ابجکت های ساختگی به وراثت متکی هستند. از آنجایی که سازنده کلاس 
 singleton
  خصوصی است و غلبه بر روش‌های استاتیک در بیشتر زبان‌ها غیرممکن است، باید راه  بیاندیشید
 یا فقط تست ها را ننویسید. یا از الگوی 
  Singleton
   استفاده نکنید
   ### 🔄  ارتباط با سایر الگو ها 
   
یک کلاس Facade اغلب می تواند به یک Singleton     تبدیل شود زیرا یک شی نما در بیشتر موارد کافی است.

الگوی Flyweight
 شبیه
  Singleton
   خواهد بود اگر بتوانید به نحوی تمام حالات مشترک اشیاء را به یک جسم با وزن پرواز کاهش دهید. اما دو تفاوت اساسی بین این الگوها وجود دارد:

فقط یک نمونه 
Singleton 
باید وجود داشته باشد
، در حالی که یک کلاس
 Flyweight
  می تواند چندین نمونه با حالت های ذاتی مختلف داشته باشد.

شی 
Singleton 
می تواند قابل تغییر باشد. اجسام با 
flyweight
 تغییرناپذیر هستند.

الگوهای Abstract Factories، Builders  و Prototypes  همگی می‌توانند به‌عنوان 
Singletons 
پیاده‌سازی شوند.
