# متود کارخانه[^1]

## همچنین به عنوان: سازنده مجازی[^2]

**متود کارخانه** یک الگوی طراحی خلاقانه است که رابطی برای ایجاد اشیاء در یک سوپرکلاس فراهم می‌کند، اما به زیر کلاس‌ها اجازه می‌دهد تا نوع اشیایی که ایجاد می‌شوند را تغییر دهند.

### :worried: مشکل

تصور کنید که در حال ایجاد یک برنامه مدیریت لجستیک هستید. اولین نسخه برنامه شما فقط می تواند حمل و نقل با کامیون را انجام دهد، بنابراین بخش عمده کد شما در کلاس Truck قرار دارد.

پس از مدتی، برنامه شما بسیار محبوب می شود. هر روز ده ها درخواست از شرکت های حمل و نقل دریایی برای گنجاندن تدارکات دریایی در برنامه دریافت می کنید.

![problem1-en](images/diagrams/factory-method/problem1-en.png)

اگر بقیه کدها قبلاً با کلاس های موجود همراه شده باشند، اضافه کردن یک کلاس جدید به برنامه به این سادگی نیست.

خبر عالی، درست است؟ اما در مورد کد چطور؟ در حال حاضر، بیشتر کد شما با کلاس `Truck` همراه است. افزودن `Ships` به برنامه نیازمند ایجاد تغییراتی در کل پایگاه کد است. علاوه بر این، اگر بعداً تصمیم گرفتید نوع دیگری از حمل و نقل را به برنامه اضافه کنید، احتمالاً باید همه این تغییرات را دوباره انجام دهید.

در نتیجه، کد بسیار بدی خواهید داشت که مملو از شرایطی است که رفتار برنامه را بسته به کلاس اشیاء حمل‌ونقل تغییر می‌دهد.

### :smiley: راه حل

الگوی متود کارخانه پیشنهاد می‌کند که به جای مستقیم صدا زدن متود سازنده شی (با استفاده از اپراتور new()) با فراخوانی متود کارخانه (factory method) خاص جایگزین کنید. نگران نباشید؛ اشیاء هنوز از طریق اپراتور new() ایجاد می شوند، اما از متود کارخانه فراخوانی می شوند. اشیایی که با متود کارخانه ای بازگردانده می شوند اغلب به عنوان محصولات شناخته می شوند.

![solution1](images/diagrams/factory-method/solution1.png)

زیر کلاس ها می توانند کلاس اشیایی را که با متود کارخانه برگردانده می شوند تغییر دهند.

در نگاه اول، این تغییر ممکن است بی معنی به نظر برسد: ما فقط فراخوان سازنده را از یک قسمت برنامه به قسمت دیگر منتقل کردیم. با این حال، این را در نظر بگیرید: اکنون می توانید متود کارخانه را در یک زیر کلاس لغو کنید و کلاس محصولات ایجاد شده توسط متود[^3] را تغییر دهید.

با این حال، یک محدودیت جزئی وجود دارد: کلاس‌های فرعی ممکن است انواع مختلف محصولات را تنها در صورتی برگردانند که این محصولات دارای یک کلاس پایه یا رابط مشترک باشند. همچنین متود کارخانه در کلاس پایه باید نوع بازگشتی خود را به عنوان این رابط اعلام کند.

![solution2-en](images/diagrams/factory-method/solution2-en.png)

برای مثال، هر دو کلاس `Truck` و `Ship` باید رابط `Transport` را پیاده‌سازی کنند، که متودی به نام `deliver` را اعلام می‌کند. هر کلاس این متود را متفاوت اجرا می کند: کامیون ها محموله را از طریق زمینی و کشتی ها محموله را از طریق دریا تحویل می دهند. متود کارخانه در کلاس `RoadLogistics` اشیاء کامیون را برمی‌گرداند، در حالی که متود کارخانه در کلاس `SeaLogistics` کشتی‌ها را برمی‌گرداند.

کدی که از متود کارخانه استفاده می کند (اغلب کد کلاینت[^4] نامیده می شود) تفاوتی بین محصولات واقعی بازگردانده شده توسط زیر کلاس های مختلف نمی بیند. کلاینت با تمام محصولات به عنوان `Transport` انتزاعی برخورد می کند.

![Truck](images/diagrams/factory-method/solution3-en.png)

تا زمانی که همه کلاس‌های محصول یک رابط مشترک را پیاده‌سازی کنند، می‌توانید اشیاء آنها را بدون شکستن آن به کد کلاینت منتقل کنید.

کلاینت می داند که قرار است همه اشیاء حمل و نقل دارای متود `deliver` باشند، اما نحوه عملکرد دقیق آن برای کلاینت مهم نیست.

### :construction: ساختار

![structure-indexed](images/diagrams/factory-method/structure-indexed.png)

1. اینترفیس **Product** اعلام می کند که برای همه اشیایی که می توانند توسط سازنده و زیر کلاس های آن تولید شوند مشترک است.

2. پیاده سازی روابط مختلف **Concrete Products**  است.

3. کلاس **Creator** متود کارخانه ای را اعلام می کند که اشیاء محصول جدید را برمی گرداند. مهم است که نوع بازگشت این متود با رابط محصول مطابقت داشته باشد.

می‌توانید متد کارخانه را به‌عنوان انتزاعی اعلام کنید تا همه زیر کلاس‌ها مجبور شوند نسخه‌های خود را از متد پیاده‌سازی کنند. به عنوان یک جایگزین، متود کارخانه پایه می تواند برخی از انواع محصولات پیش فرض را برگرداند.

توجه داشته باشید، با وجود نام آن، ایجاد محصول **نه** مسئولیت اصلی سازنده است. بلکه، کلاس سازنده از قبل دارای منطق تجاری اصلی مرتبط با محصولات است. متود کارخانه کمک می کند تا این منطق از کلاس های غیر انتزاعی محصولات جدا شود. در اینجا یک قیاس وجود دارد: یک شرکت بزرگ توسعه نرم افزار می تواند یک بخش آموزشی برای برنامه نویسان داشته باشد. با این حال، وظیفه اصلی شرکت به عنوان یک کل هنوز هم نوشتن کد است، نه تولید برنامه نویس.

4. **Concrete Creators** روش کارخانه پایه را نادیده می گیرد بنابراین نوع متفاوتی از محصول را برمی گرداند.

توجه داشته باشید که روش کارخانه نیازی به **ایجاد** نمونه های جدید ندارد. همچنین می تواند اشیاء موجود را از یک کش، یک مخزن آبجکت یا منبع دیگری برگرداند.

### :hash: شبه کد

این مثال نشان می‌دهد که چگونه می‌توان از **روش کارخانه** برای ایجاد عناصر رابط کاربری متقابل پلتفرم بدون جفت کردن کد مشتری با کلاس‌های رابط کاربری مشخص استفاده کرد.

کلاس گفتگوی پایه از عناصر UI مختلف برای ارائه پنجره خود استفاده می کند. تحت سیستم عامل های مختلف، این عناصر ممکن است کمی متفاوت به نظر برسند، اما همچنان باید به طور مداوم رفتار کنند. یک دکمه در ویندوز همان دکمه در لینوکس است.

![example](images/diagrams/factory-method/example.png)

مثال گفتگوی بین پلتفرمی.

هنگامی که روش کارخانه وارد عمل می شود، نیازی به بازنویسی منطق گفتگو برای هر سیستم عامل ندارید. اگر یک متد کارخانه ای را اعلام کنیم که دکمه هایی را در داخل کلاس گفتگوی پایه تولید می کند، بعداً می توانیم یک زیر کلاس گفتگو ایجاد کنیم که دکمه های استایل ویندوز را از روش کارخانه برمی گرداند. سپس کلاس فرعی بیشتر کدهای گفتگو را از کلاس پایه به ارث می برد، اما به لطف روش کارخانه، می تواند دکمه های شبیه به ویندوز را روی صفحه نمایش دهد.

برای اینکه این الگو کار کند، کلاس محاوره ای پایه باید با دکمه های انتزاعی کار کند: یک کلاس پایه یا یک رابط که همه دکمه های غیر انتزاعی از آن پیروی می کنند. به این ترتیب کد دیالوگ، با هر نوع دکمه ای که کار می کند، کاربردی باقی می ماند.

البته، می‌توانید این رویکرد را در سایر عناصر رابط کاربری نیز اعمال کنید. با این حال، با هر روش کارخانه جدیدی که به دیالوگ اضافه می کنید، به الگوی **Abstract Factory** نزدیک می شوید. نترسید، بعداً در مورد این الگو صحبت خواهیم کرد.

```c++
// کلاس creator متد کارخانه ای را اعلام می کند که باید
// یک شی از یک کلاس محصول را برمی گرداند. زیر کلاس های سازنده
// معمولاً اجرای این روش را ارائه می دهد.

    class Dialog is
    // سازنده همچنین ممکن است برخی از پیاده سازی های پیش فرض را از طریق متود کارخانه ارائه دهد.

    abstract method createButton():Button

    // توجه داشته باشید که علیرغم نام آن، مسئولیت اصلی سازنده، ایجاد محصولات نیست. 
    // معمولاً حاوی برخی منطق اصلی تجاری است که بر اشیاء محصول بازگردانده شده با روش کارخانه تکیه دارد.
    // زیر کلاس‌ها می‌توانند به طور غیرمستقیم منطق تجاری را با نادیده گرفتن
    // روش کارخانه و بازگرداندن نوع متفاوتی از محصول از آن تغییر دهند.

    method render() is
        // برای ایجاد یک شی محصول، متد کارخانه را فراخوانی کنید.
        Button okButton = createButton()
        // حال از محصول استفاده کنید.
        okButton.onClick(closeDialog)
        okButton.render()

// Concrete creators برای تغییر نوع محصول حاصل، روش کارخانه را نادیده می گیرند.
class WindowsDialog extends Dialog is

    method createButton():Button is
        return new WindowsButton()

class WebDialog extends Dialog is

    method createButton():Button is
        return new HTMLButton()

// رابط محصول عملیاتی را که همه Concrete creators باید اجرا کنند را اعلام می کند.
interface Button is

    method render()
    method onClick(f)

// محصولات بتنی پیاده سازی های مختلفی از رابط محصول را ارائه می دهند.
class WindowsButton implements Button is

    method render(a, b) is
        // یک دکمه به سبک ویندوز رندر کنید.
    method onClick(f) is
        // پیوند یک رویداد کلیکی بومی سیستم عامل.

class HTMLButton implements Button is

    method render(a, b) is
        // نمایش HTML یک دکمه را برگردانید.
    method onClick(f) is
        // پیوند یک رویداد کلیک مرورگر وب.

class Application is

    field dialog: Dialog

    // برنامه بسته به پیکربندی فعلی یا تنظیمات محیط، نوع سازنده را انتخاب می کند.
    method initialize() is

    config = readApplicationConfigFile()

    if (config.OS == "Windows") then
        dialog = new WindowsDialog()
    else if (config.OS == "Web") then
        dialog = new WebDialog()
    else
        throw new Exception("Error! Unknown operating system.")

// کد کلاینت با نمونه ای از یک concrete creator, کار می کند، البته از طریق رابط پایه آن. تا زمانی که مشتری از طریق رابط پایه با سازنده کار می کند، می توانید آن را به زیر کلاس هر سازنده ای منتقل کنید.

method main() is

    this.initialize()
    dialog.render()

```

### :bulb: کاربر

:beetle: **زمانی که از قبل از انواع و وابستگی های دقیق اشیایی که کد شما باید با آنها کار کند، نمی دانید، از روش کارخانه استفاده کنید.**

:sparkles: متود کارخانه کد ساخت محصول را از کدی که در واقع از محصول استفاده می کند جدا می کند. بنابراین، گسترش کد ساخت محصول به طور مستقل از بقیه کد آسان تر است.

به عنوان مثال، برای افزودن یک نوع محصول جدید به برنامه، فقط باید یک زیر کلاس سازنده جدید ایجاد کنید و روش کارخانه را در آن لغو کنید.

**زمانی که می خواهید به کاربران کتابخانه یا چارچوب خود راهی برای گسترش اجزای داخلی آن ارائه دهید، از روش کارخانه استفاده کنید.**

وراثت احتمالاً ساده ترین راه برای گسترش رفتار پیش فرض یک کتابخانه یا فریمورک است. اما فریمورک چگونه تشخیص می دهد که زیر کلاس شما باید به جای یک جزء استاندارد استفاده شود؟

راه حل این است که کدی را که اجزاء را در سرتاسر چارچوب می سازد به یک روش کارخانه ای واحد کاهش دهیم و به هر کسی اجازه دهیم این روش را علاوه بر گسترش خود مؤلفه لغو کند.

بیایید ببینیم که چگونه کار می کند. تصور کنید که یک برنامه را با استفاده از یک چارچوب UI منبع باز می نویسید. برنامه شما باید `buttons` گرد داشته باشد، اما چارچوب فقط دکمه‌های مربعی را ارائه می‌کند. شما کلاس دکمه استاندارد را با یک زیر کلاس با شکوه `RoundButton` گسترش می دهید. اما اکنون باید به کلاس اصلی `UIFramework` بگویید که از زیر کلاس دکمه جدید به جای یک کلاس پیش فرض استفاده کند.

برای رسیدن به این هدف، یک زیر کلاس `UIWithRoundButtons` از یک کلاس چارچوب پایه ایجاد می‌کنید و روش `createButton` آن را لغو می‌کنید. در حالی که این متد اشیاء `Button` را در کلاس پایه برمی گرداند، شما در زیر کلاس خود اشیاء `RoundButton` را برمی گرداند. اکنون از کلاس `UIWithRoundButtons` به جای `UIFramework` استفاده کنید. و این در مورد آن است!

**زمانی که می خواهید منابع سیستم را با استفاده مجدد از اشیاء موجود به جای بازسازی هر بار، ذخیره کنید، از روش کارخانه استفاده کنید.**

شما اغلب این نیاز را هنگام برخورد با اشیاء بزرگ و پرمخاطب مانند اتصالات پایگاه داده، سیستم های فایل و منابع شبکه تجربه می کنید.

بیایید به این فکر کنیم که برای استفاده مجدد از یک شی موجود چه کاری باید انجام شود:

1. ابتدا باید مقداری فضای ذخیره سازی ایجاد کنید تا تمام اشیاء ایجاد شده را ردیابی کنید.

2. هنگامی که شخصی یک شی را درخواست می کند، برنامه باید به دنبال یک شی آزاد در داخل آن استخر باشد.

3. … و سپس آن را به کد مشتری برگردانید.

4. اگر هیچ شی آزاد وجود ندارد، برنامه باید یک مورد جدید ایجاد کند (و آن را به استخر اضافه کند).

این تعداد زیادی کد است! و همه باید در یک مکان قرار داده شوند تا برنامه را با کدهای تکراری کثیف نشود.

احتمالا واضح‌ترین و راحت‌ترین مکانی که می‌توان این کد را در آن قرار داد، سازنده کلاسی است که از اشیاء آن می‌خواهیم دوباره استفاده کنیم. با این حال، سازنده همیشه باید **اشیاء جدید** را طبق تعریف برگرداند. نمی تواند نمونه های موجود را برگرداند.

بنابراین، شما باید یک روش منظم داشته باشید که قادر به ایجاد اشیاء جدید و همچنین استفاده مجدد از موارد موجود باشد. این به نظر بسیار شبیه یک روش کارخانه ای است.

### :clipboard: نحوه پیاده سازی

1. کاری کنید که همه محصولات از یک رابط استفاده کنند. این رابط باید روش‌هایی را که در هر محصول معنادار هستند را بیان کند.

2. یک متد خالی کارخانه داخل کلاس creator اضافه کنید. نوع برگشت روش باید با رابط محصول مشترک مطابقت داشته باشد.

3. در کد سازنده همه ارجاعات به سازنده های محصول را بیابید. یک به یک آنها را با فراخوانی به روش کارخانه جایگزین کنید، در حالی که کد ایجاد محصول را به روش کارخانه استخراج کنید.

ممکن است لازم باشد یک پارامتر موقت به روش کارخانه اضافه کنید تا نوع محصول برگشتی را کنترل کنید.

در این مرحله، کد روش کارخانه ممکن است بسیار زشت به نظر برسد. ممکن است یک اپراتور «سوئیچ `switch` بزرگ داشته باشد که کلاس محصول را برای نمونه سازی انتخاب می کند. اما نگران نباشید، به زودی آن را برطرف خواهیم کرد.

4. اکنون برای هر نوع محصول فهرست شده در روش کارخانه، مجموعه ای از زیر کلاس های سازنده ایجاد کنید. روش کارخانه ای را در زیر کلاس ها لغو کنید و بیت های کد ساخت مناسب را از روش پایه استخراج کنید.

5. اگر انواع محصول بسیار زیاد است و ایجاد زیر کلاس برای همه آنها منطقی نیست، می توانید از پارامتر کنترل از کلاس پایه در زیر کلاس ها استفاده مجدد کنید.

به عنوان مثال، تصور کنید که شما سلسله مراتب طبقات زیر را دارید: کلاس پایه 'Mail' با چند زیرکلاس: `AirMail` و `GroundMail` . کلاس های `Transport` عبارتند از `Plane` , `Truck` و `Train` . در حالی که کلاس `AirMail` فقط از اشیاء Plane استفاده می کند، `GroundMail` ممکن است با اشیاء `Truck` و `Train` کار کند. می‌توانید یک زیر کلاس جدید (مثلا `TrainMail` ) برای رسیدگی به هر دو مورد ایجاد کنید، اما گزینه دیگری وجود دارد. کد کلاینت می‌تواند آرگومان را به متد کارخانه کلاس `GroundMail` ارسال کند تا بتواند محصولی را که می‌خواهد دریافت کند، کنترل کند.

6. اگر بعد از تمام استخراج ها، روش کارخانه پایه خالی شد، می توانید آن را انتزاعی کنید. اگر چیزی باقی مانده است، می‌توانید آن را به‌عنوان رفتار پیش‌فرض متد درآورید.

### ⚖️ مزایا و معایب

:heavy_check_mark: شما از اتصال محکم بین creator و concrete products اجتناب می کنید.

:heavy_check_mark: اصل مسئولیت واحد می‌توانید کد ایجاد محصول را به یک مکان در برنامه منتقل کنید تا پشتیبانی از کد آسان‌تر شود.

:heavy_check_mark: اصل باز/بسته شما می توانید انواع جدیدی از محصولات را بدون شکستن کد مشتری موجود به برنامه معرفی کنید.

:heavy_multiplication_x: ممکن است کد پیچیده‌تر شود زیرا برای پیاده‌سازی الگو باید زیر کلاس‌های جدید زیادی معرفی کنید. بهترین حالت زمانی است که شما الگو را در یک سلسله مراتب موجود از کلاس‌های سازنده معرفی می‌کنید.

### :arrows_counterclockwise: روابط با الگوهای دیگر

* بسیاری از طرح ها با استفاده از **Factory Method** (کمتر پیچیده و قابل تنظیم تر از طریق زیر کلاس ها) شروع می شوند و به سمت **Abstract Factory**، **Prototype** یا **Builder** (انعطاف پذیرتر، اما پیچیده تر) تکامل می یابند. ).

* کلاس های **Abstract Factory** اغلب بر اساس مجموعه ای از **Factory Methods** هستند، اما شما همچنین می توانید از **Prototype** برای نوشتن متدهای این کلاس ها استفاده کنید.

* می‌توانید از **Factory Method** به همراه **Iterator** استفاده کنید تا به زیر کلاس‌های مجموعه اجازه دهید انواع مختلفی از تکرارکننده‌ها را که با مجموعه‌ها سازگار هستند، برگردانند.

* **Prototype** مبتنی بر وراثت نیست، بنابراین اشکالاتی ندارد. از سوی دیگر، Prototype به یک مقداردهی اولیه پیچیده از شی کلون شده نیاز دارد. **Factory Method**بر اساس وراثت است اما نیازی به مرحله اولیه سازی ندارد.

* **Factory Method**تخصص *Template Method** است. در همان زمان، یک روش کارخانه ممکن است به عنوان مرحله ای در یک روش الگوی بزرگ عمل کند.

---

![abstract-factory-en](images/content/abstract-factory/abstract-factory-en.png)

## پینوشت

[^1]: Factory Method
[^2]: Virtual Constructor
[^3]: Method
[^4]: Client
